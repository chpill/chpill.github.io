<!DOCTYPE html>
<html><head><title>Getting a feel for closeables</title><meta charset="utf-8" /><link href="/assets/pandoc-gfm.css" rel="stylesheet" /></head><body><header><nav><p><span style="padding-right:2rem;">Chpill&apos;s (Over) Engineering Log</span><a href="/">about</a> - <a href="/en/posts">posts</a></p></nav></header><main><h1 id="getting-a-feel-for-closeables">Getting a feel for
closeables</h1>
<p><em>2023-11-05</em></p>
<p>The other day, I stumbled upon <a
href="https://medium.com/@maciekszajna/reloaded-workflow-out-of-the-box-be6b5f38ea98">this
article by Maciej Szajna</a> which presents a minimalist way to declare
and manage runtime state in your Clojure programs. Having used <a
href="https://github.com/stuartsierra/component">Components</a>, <a
href="https://github.com/weavejester/integrant/">Integrant</a> and then
<a href="https://github.com/juxt/clip">Clip</a>, this felt almost like
cheating. Can something so simple actually work? Well, it actually does
pretty well. Let's illustrate that by implementing a web server, pretty
barebone, but with some "reloaded workflow". This won't be much more
than a special case for the pattern demonstrated in the <a
href="https://medium.com/@maciekszajna/reloaded-workflow-out-of-the-box-be6b5f38ea98">Maciej's
article</a>, but it will serve as a foundation to build upon in future
posts.</p>
<h2 id="a-barebone-webserver">A barebone webserver</h2>
<p>If you want to evaluate the code for yourself, you can find the
following examples in <a
href="https://github.com/chpill/demo-closeable/tree/master/barebone-webserver">this
repository</a>.</p>
<p>First, let's add the <code>closeable</code> helper:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> closeable</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  ([value] (closeable value <span class="kw">identity</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  ([value close]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">reify</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     clojure.lang.IDeref (<span class="kw">deref</span> [_] value)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     java.io.Closeable (close [_] (close value)))))</span></code></pre></div>
<p>Now, let's add a very basic webserver, that shows only one page. It
increments and displays a counter each time it is served:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">require</span> &#39;[ring.adapter.jetty <span class="at">:refer</span> [run-jetty]])</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> run-with-webserver </span>[config f]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">with-open</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    [counter (closeable (<span class="kw">atom</span> <span class="dv">42</span>))</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>     handler (closeable (<span class="kw">fn</span> [_req]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>                          {<span class="at">:status</span> <span class="dv">200</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                           <span class="at">:body</span> (<span class="kw">str</span> <span class="st">&quot;Counter: &quot;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                                      (<span class="kw">swap!</span> <span class="at">@counter</span> <span class="kw">inc</span>))}))</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>     webserver (closeable (run-jetty <span class="at">@handler</span> {<span class="at">:port</span> (<span class="at">:port</span> config)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                                               <span class="at">:join</span>? <span class="va">false</span>})</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                          #(.stop <span class="va">%</span>))]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    (f <span class="at">@webserver</span>)))</span></code></pre></div>
<p>Compared to the <a
href="https://medium.com/@maciekszajna/reloaded-workflow-out-of-the-box-be6b5f38ea98">Maciej's
article</a>, you may notice 2 main differences in this example:</p>
<ol type="1">
<li><p>It does not return a function that closes over the configuration,
and it does not bother building an associative map with every binding
declared in <code>with-open</code>.</p></li>
<li><p><code>run-with-webserver</code> is much more specific than the
generic <code>with-my-system</code>. The main side effect of calling
this function is to open up a port on the host where it is run, so I
prefer to narrow the meaning to reflect that.</p></li>
</ol>
<p>We can see it in action by evaluating the following expression:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>(run-with-webserver {<span class="at">:port</span> <span class="dv">54321</span>}</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                    (<span class="kw">fn</span> [_webserver]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                      (<span class="kw">println</span> <span class="st">&quot;The server is live:&quot;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                               (<span class="kw">slurp</span> <span class="st">&quot;http://localhost:54321&quot;</span>))))</span></code></pre></div>
<p>It should print <code>The server is live: Counter: 43</code> in your
REPL (among other log statements). That is well and good, but if you try
to access <a href="http://localhost:54321">http://localhost:54321</a>
from your browser, you'll see that the server is not actually running
anymore. As explained in the <a
href="https://medium.com/@maciekszajna/reloaded-workflow-out-of-the-box-be6b5f38ea98">Maciej's
article</a>, once the function we pass to
<code>run-with-webserver</code> returns, the opened resources are
released. In order to keep the server running indefinitely, we can use
<a
href="https://eclipse.dev/jetty/javadoc/jetty-11/org/eclipse/jetty/server/Server.html#join()"><code>.join</code>
on the Jetty Server</a>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(run-with-webserver {<span class="at">:port</span> <span class="dv">54321</span>} #(.<span class="kw">join</span> <span class="va">%</span>))</span></code></pre></div>
<p><strong>NB: Depending on your tooling, evaluating the previous
expression can block your REPL. You'll need to interupt the evaluation
to stop the webserver.</strong></p>
<h2 id="testing">Testing</h2>
<p>It felt odd at first having the "run" function not do its task
indefinitely. After all, Clojure was made for <a
href="https://youtu.be/2V1FtfBDsLU?t=646">Situated programs</a>, long
running processes tangled with outside world. But it makes it a lot
easier to work with our system in various ways. Testing is effortless
for example:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">require</span> &#39;[clojure.<span class="kw">test</span> <span class="at">:refer</span> [<span class="bu">deftest</span><span class="fu"> is </span><span class="kw">run-tests</span>]])</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>(<span class="bu">deftest</span><span class="fu"> test-webserver</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [url <span class="st">&quot;http://localhost:12345&quot;</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">is</span> (thrown? java.net.ConnectException (<span class="kw">slurp</span> url)))</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    (run-with-webserver {<span class="at">:port</span> <span class="dv">12345</span>}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                        (<span class="kw">fn</span> [_webserver]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                          (<span class="kw">is</span> (<span class="kw">=</span> (<span class="kw">slurp</span> url) <span class="st">&quot;Counter: 43&quot;</span>))</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                          (<span class="kw">is</span> (<span class="kw">=</span> (<span class="kw">slurp</span> url) <span class="st">&quot;Counter: 44&quot;</span>))))</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">is</span> (thrown? java.net.ConnectException (<span class="kw">slurp</span> url)))))</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>(<span class="kw">comment</span> (<span class="kw">run-tests</span>))</span></code></pre></div>
<h2 id="the-famous-reloaded-workflow">The famous "reloaded"
workflow</h2>
<p>Finally, let's add some convenient handles (in <code>user.clj</code>)
to play with our webserver from the REPL.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode clj"><code class="sourceCode clojure"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defonce</span><span class="fu"> *live-server </span>(<span class="kw">atom</span> (<span class="kw">future</span> <span class="at">::not-initialized-yet</span>)))</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> start! </span>[]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">reset!</span> *live-server (<span class="kw">future</span> (run-with-webserver {<span class="at">:port</span> <span class="dv">54321</span>}</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>                                                   #(.<span class="kw">join</span> <span class="va">%</span>)))))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> stop! </span>[]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">future-cancel</span> <span class="at">@*live-server</span>))</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>(<span class="kw">comment</span> (start!)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>         (stop!))</span></code></pre></div>
<p>After evaluating this code and calling <code>(start!)</code>, you
should be able to visit <a
href="http://localhost:54321">http://localhost:54321</a> and see the
counter for yourself. But do not call this by hand! Your editor probably
has some integration with tools.namespace via a plugin. For example for
Emacs and Cider, I usually declare a <code>.dir-locals.el</code> at the
root of the projet with the following:</p>
<pre class="emacs"><code>((clojure-mode . ((cider-ns-refresh-before-fn . &quot;user/stop!&quot;)
                  (cider-ns-refresh-after-fn  . &quot;user/start!&quot;))))</code></pre>
<p>I can then call <code>cider-ns-refresh</code> to stop my system,
refresh the namespaces, and start the system again. Notice that I still
<code>defonce</code> the reference to the live server, so that I do not
lose it if I eval the whole buffer. I also provide a dummy future in
that reference so that I can call <code>cider-ns-refresh</code> to start
my system the first time.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Even though I do not yet have had a lot experience with this
approach, there are already <a
href="https://www.juxt.pro/blog/clojure-in-griffin/">positive
reports</a> of its use, so I'm eager to use it in my projects going
forward. In the next post, we'll explore a slightly meatier example of
web server.</p>
</main><footer style="margin-top:3rem;text-align:center;"><hr /><p><small>Made with <a href="https://hackage.haskell.org/package/pandoc-cli">Pandoc</a></small></p></footer></body></html>